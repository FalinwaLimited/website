Code generated by python:

```python

import geopandas as gpd
import folium
from shapely.geometry import Point, box
import numpy as np
import json

# --- MAP CONFIG ---
DOT_SPACING_METERS = 183000   # grid spacing (Mercator meters)
DOT_RADIUS_METERS  = 54000    # base dot radius at equator (meters)
HOVER_SCALE        = 1.2      # dot growth factor on hover
SCALE_Y            = 0.80     # <1 squashes latitude so continents look wider
LAT_MAX            = 77.5     # hard cutoff to drop high-arctic islands

# ---------- Load + prep ----------
try:
    world = gpd.read_file("data/ne_110m_admin_0_countries.shp")
except Exception:
    print("Could not load custom shapefile, using geopandas default.")
    world = gpd.read_file(gpd.datasets.get_path('naturalearth_lowres'))
    world = world.rename(columns={'continent': 'CONTINENT', 'name': 'NAME'})

# Drop unwanted regions (also removes Svalbard and Jan Mayen)
world = world[~world['CONTINENT'].isin(['Antarctica', 'North America', 'South America', 'Seven seas (open ocean)'])]
world = world[~world['NAME'].isin(['New Zealand', 'French Guiana', 'Svalbard and Jan Mayen'])]

# 1) Trim far-left longitudes; 2) Hard cap latitude at LAT_MAX to remove arctic islands
world = gpd.clip(world, box(-25, -90, 180, 90))
world = gpd.clip(world, box(-25, -90, 180, LAT_MAX))
world.geometry = world.buffer(0)

# Mercator
world_merc = world.to_crs(epsg=3857)

# Visual widen: squash Y
world_scaled = world_merc.copy()
world_scaled.geometry = world_scaled.affine_transform([1, 0, 0, SCALE_Y, 0, 0])

# ---------- Grid in scaled Mercator ----------
xmin, ymin, xmax, ymax = world_scaled.total_bounds
x_coords = np.arange(xmin, xmax, DOT_SPACING_METERS)
y_coords = np.arange(ymin, ymax, DOT_SPACING_METERS)
points = [Point(x, y) for x in x_coords for y in y_coords]
points_gdf_scaled = gpd.GeoDataFrame(geometry=points, crs="EPSG:3857")

# Land dots (scaled)
land_dots_scaled = (
    gpd.sjoin(points_gdf_scaled, world_scaled, how="inner", predicate="intersects")
    .drop_duplicates(subset='geometry')
)

# ---------- Countries ----------
countries_to_highlight = {
    "Japan":     {"color": "#d53664", "url": "https://www.falinwa.com/japan"},
    "China":     {"color": "#00561b", "url": "https://www.falinwa.com/china"},
    "Indonesia": {"color": "#dc0c23", "url": "https://www.falinwa.com/indonesia"},
    "France":    {"color": "#00758f", "url": "https://www.falinwa.com/france"},
    "Cambodia":  {"color": "#F1C338", "url": "https://www.falinwa.com/cambodia"},
    "Vietnam":   {"color": "#32ac5c", "url": "https://www.falinwa.com/vietnam"},
}
singapore_latlon = (3.2, 104.4)
singapore_color  = "#4babbb"
singapore_url    = "https://www.falinwa.com/singapore"

def slugify(name: str) -> str:
    return name.lower().replace(" ", "-")

def scale_country_geom_to_mercator(name: str) -> gpd.GeoDataFrame:
    country = world[world["NAME"] == name]
    if country.empty:
        print(f"Warning: Country '{name}' not found.")
        return gpd.GeoDataFrame(geometry=[], crs="EPSG:3857")
    g = country.to_crs(epsg=3857)
    g["geometry"] = g.affine_transform([1, 0, 0, SCALE_Y, 0, 0])
    return g

def get_country_dots(name: str) -> gpd.GeoDataFrame:
    country_scaled = scale_country_geom_to_mercator(name)
    if country_scaled.empty:
        return gpd.GeoDataFrame(geometry=[], crs="EPSG:3857")
    return gpd.sjoin(points_gdf_scaled, country_scaled, how="inner", predicate="intersects")

def latlon_to_scaled_latlon(lat, lon):
    pt_m = gpd.GeoSeries([Point(lon, lat)], crs="EPSG:4326").to_crs(epsg=3857).iloc[0]
    pt_m_scaled = Point(pt_m.x, pt_m.y * SCALE_Y)
    pt_ll = gpd.GeoSeries([pt_m_scaled], crs="EPSG:3857").to_crs(epsg=4326).iloc[0]
    return pt_ll.y, pt_ll.x

def squares_from_points_merc(points_gdf: gpd.GeoDataFrame, half: float) -> gpd.GeoDataFrame:
    if points_gdf.empty:
        return gpd.GeoDataFrame(geometry=[], crs="EPSG:4326")
    from shapely.geometry import box as sbox
    polys = [sbox(p.x - half, p.y - half, p.x + half, p.y + half) for p in points_gdf.geometry]
    gdf = gpd.GeoDataFrame(geometry=polys, crs="EPSG:3857").to_crs(epsg=4326)
    return gdf

# ---------- Folium map (responsive to iframe) ----------
m = folium.Map(
    tiles=None,
    attr="Falinwa",
    zoom_control=False,
    scrollWheelZoom=False,
    dragging=False,
    doubleClickZoom=False,
    prefer_canvas=True,
    width="100%",     # fill iframe width
    height="100%"     # fill iframe height
)

# Base CSS
m.get_root().header.add_child(folium.Element("""
<style>
  html, body { height: 100%; margin: 0; background: transparent !important; }
  body > div, body > div > div { height: 100% !important; background: transparent !important; }
  .folium-map, .leaflet-container {
    width: 100% !important;
    height: 100% !important;
    border: 0 !important;
    outline: none !important;
    background: transparent !important;
  }
  .leaflet-pane,
  .leaflet-tile-pane,
  .leaflet-overlay-pane,
  .leaflet-shadow-pane,
  .leaflet-marker-pane,
  .leaflet-tooltip-pane,
  .leaflet-control-container { background: transparent !important; }
  canvas.leaflet-zoom-animated, svg.leaflet-zoom-animated { background: transparent !important; }
  .leaflet-control-attribution { display: none !important; }
  .leaflet-interactive { cursor: default !important; }
  .hitbox-capture { cursor: pointer !important; }
  path.hitbox-squares { pointer-events: none !important; }
</style>
"""))

# Pills + Quicksand font
m.get_root().header.add_child(folium.Element("""
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@700&display=swap" rel="stylesheet">
<style>
  .country-pill{
    position:fixed;                 /* anchor to viewport, not the map div */
    left:0; top:0;
    display:none;
    padding:6px 14px;               /* a bit more space */
    background:#ffffff !important;  /* solid white */
    border-radius:9999px;
    box-shadow:0 1px 3px rgba(0,0,0,.2);
    font:700 16px "Quicksand", system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Liberation Sans", sans-serif;
    line-height:20px;
    white-space:nowrap;
    height:auto !important;         /* never stretch vertically */
    max-height:40px;                /* safety */
    box-sizing:border-box;
    z-index:10000;
    pointer-events:none;
  }
</style>
"""))


# Helper: add a Mercator circle with cos(lat) compensation + className
def add_meter_circle(display_lat, display_lon, color_hex, class_name="", scale=1.0):
    adj_radius_m = float(DOT_RADIUS_METERS) * float(np.cos(np.radians(display_lat))) * float(scale)
    folium.Circle(
        location=[display_lat, display_lon],
        radius=adj_radius_m,
        color=color_hex,
        fill=True,
        fill_color=color_hex,
        fill_opacity=1.0,
        weight=0,
        className=class_name,
        interactive=False
    ).add_to(m)

# Background land dots (white, non-interactive)
for _, row in land_dots_scaled.iterrows():
    lon, lat = gpd.GeoSeries([row.geometry], crs="EPSG:3857").to_crs(epsg=4326).iloc[0].coords[0]
    add_meter_circle(lat, lon, "#ffffff", class_name="dot dot-land")

# Highlighted countries + transparent hitboxes
half = DOT_SPACING_METERS / 2.0
for name, data in countries_to_highlight.items():
    slug = slugify(name)
    dots = get_country_dots(name)
    if dots.empty:
        continue

    for _, row in dots.iterrows():
        lon, lat = gpd.GeoSeries([row.geometry], crs="EPSG:3857").to_crs(epsg=4326).iloc[0].coords[0]
        add_meter_circle(lat, lon, data['color'], class_name=f"dot dot-country-{slug}")

    hitboxes_ll = squares_from_points_merc(dots, half)
    folium.GeoJson(
        data=json.loads(hitboxes_ll.to_json()),
        name=f"hitbox-squares-{slug}",
        style_function=lambda feat: {
            "weight": 0, "opacity": 0, "fillColor": "#000000",
            "fillOpacity": 0.0, "className": "hitbox-squares"
        },
        tooltip=None,
        interactive=False
    ).add_to(m)

    merged = hitboxes_ll.geometry.union_all() if hasattr(hitboxes_ll.geometry, "union_all") else hitboxes_ll.geometry.unary_union
    merged_ll = gpd.GeoDataFrame({"slug": [slug]}, geometry=[merged], crs="EPSG:4326")
    folium.GeoJson(
        data=json.loads(merged_ll.to_json()),
        name=f"hitbox-capture-{slug}",
        style_function=lambda feat: {
            "stroke": False, "weight": 0, "opacity": 0,
            "fillColor": "#000000", "fillOpacity": 0.001,  # nonzero for Canvas hit-testing
            "className": "hitbox-capture"
        },
        tooltip=None,
        interactive=True
    ).add_to(m)

# Singapore
sg_lat, sg_lon = latlon_to_scaled_latlon(*singapore_latlon)
add_meter_circle(sg_lat, sg_lon, singapore_color, class_name="dot dot-country-singapore", scale=2.0)
sg_pt_m = gpd.GeoSeries([Point(sg_lon, sg_lat)], crs="EPSG:4326").to_crs(epsg=3857).iloc[0]
from shapely.geometry import box as sbox
sg_square_ll = gpd.GeoDataFrame(geometry=[sbox(sg_pt_m.x - half, sg_pt_m.y - half, sg_pt_m.x + half, sg_pt_m.y + half)],
                                crs="EPSG:3857").to_crs(epsg=4326)
folium.GeoJson(
    data=json.loads(sg_square_ll.to_json()),
    name="hitbox-squares-singapore",
    style_function=lambda feat: {
        "weight": 0, "opacity": 0, "fillColor": "#000000",
        "fillOpacity": 0.0, "className": "hitbox-squares"
    },
    tooltip=None,
    interactive=False
).add_to(m)
sg_capture_ll = gpd.GeoDataFrame({"slug": ["singapore"]}, geometry=sg_square_ll.geometry, crs="EPSG:4326")
folium.GeoJson(
    data=json.loads(sg_capture_ll.to_json()),
    name="hitbox-capture-singapore",
    style_function=lambda feat: {
            "stroke": False, "weight": 0, "opacity": 0,
            "fillColor": "#000000", "fillOpacity": 0.001,
            "className": "hitbox-capture"
    },
    tooltip=None,
    interactive=True
).add_to(m)

# ---------- JS: hover enlarge + brighten + pill label; click opens URL; responsive sizing ----------
url_by_slug = {slugify(n): d["url"] for n, d in countries_to_highlight.items()}
url_by_slug["singapore"] = singapore_url
label_by_slug = {slugify(n): n for n in countries_to_highlight.keys()}
label_by_slug["singapore"] = "Singapore"
color_by_slug = {slugify(n): d["color"] for n, d in countries_to_highlight.items()}
color_by_slug["singapore"] = singapore_color

js = """
<script>
document.addEventListener("DOMContentLoaded", function() {
  var map_id = document.querySelector('.folium-map').id;
  var map = window[map_id];
  var HOVER_SCALE = """ + str(HOVER_SCALE) + """;
  var HOVER_BRIGHTEN = 0.22;
  var urlBySlug   = """ + json.dumps(url_by_slug) + """;
  var labelBySlug = """ + json.dumps(label_by_slug) + """;
  var colorBySlug = """ + json.dumps(color_by_slug) + """;

  // Ensure wrapper divs fill the iframe and Leaflet resizes correctly
  (function ensureFullHeight(){
    var el = document.getElementById(map_id);
    if (el && el.parentElement) el.parentElement.style.height = '100%';
    if (el && el.parentElement && el.parentElement.parentElement) el.parentElement.parentElement.style.height = '100%';
  })();
  function resizeMap(){ if (map && map.invalidateSize) map.invalidateSize(); }
  resizeMap(); window.addEventListener('resize', resizeMap);

  // --- color helpers ---
  function hexToRgb(hex){
    hex = (hex || '#000000').replace('#','');
    if (hex.length === 3) hex = hex.split('').map(function(c){return c+c;}).join('');
    var n = parseInt(hex, 16);
    return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 };
  }
  function rgbToHex(r,g,b){
    function c(v){ var h=v.toString(16); return h.length===1?'0'+h:h; }
    return '#' + c(r) + c(g) + c(b);
  }
  function brighten(hex, amt){
    var rgb = hexToRgb(hex);
    var r = Math.round(rgb.r + (255 - rgb.r) * amt);
    var g = Math.round(rgb.g + (255 - rgb.g) * amt);
    var b = Math.round(rgb.b + (255 - rgb.b) * amt);
    return rgbToHex(r,g,b);
  }

  // Gather dots by country slug
  var dotsByCountry = {};
  map.eachLayer(function(layer) {
    if (layer instanceof L.Circle) {
      var cls = (layer.options.className || '');
      var m = cls.match(/dot-country-([a-z0-9\\-]+)/);
      if (m) {
        var slug = m[1];
        if (!dotsByCountry[slug]) dotsByCountry[slug] = [];
        layer._origRadius = layer.getRadius();
        layer._baseFill   = layer.options.fillColor || '#333333';
        layer._brightFill = brighten(layer._baseFill, HOVER_BRIGHTEN);
        dotsByCountry[slug].push(layer);
      }
    }
  });

  function setCountryHover(slug, active) {
    var arr = dotsByCountry[slug] || [];
    if (!arr.length) return;
    window.requestAnimationFrame(function() {
      for (var i = 0; i < arr.length; i++) {
        var layer = arr[i];
        var r = active ? layer._origRadius * HOVER_SCALE : layer._origRadius;
        layer.setRadius(r);
        if (active) {
          layer.setStyle({ fillColor: layer._brightFill, color: layer._brightFill, weight: 1, opacity: 1.0 });
        } else {
          layer.setStyle({ fillColor: layer._baseFill, weight: 0, opacity: 0 });
        }
      }
    });
  }

  // --- hover label (pill) ---
  var pill = document.createElement('div');
  pill.className = 'country-pill';
  pill.style.display = 'none';
  pill.style.backgroundColor = '#ffffff'; // runtime fallback to guarantee white
  document.body.appendChild(pill);
  var container = map.getContainer();
  container.appendChild(pill);

  function showPill(slug, e){
    var txt = labelBySlug[slug] || slug;
    var col = colorBySlug[slug] || '#333333';
    pill.textContent = txt;
    pill.style.color = col;
    pill.style.display = 'inline-block';
    movePill(e);
  }
  function movePill(e){
    if (!e) return;
    var pt = e.containerPoint || (e.latlng ? map.latLngToContainerPoint(e.latlng) : null);
    if (!pt) return;
    var rect = container.getBoundingClientRect();  // viewport coords of map
    var x = rect.left + pt.x + 12;   // slight right offset
    var y = rect.top  + pt.y - 36;   // above cursor
    pill.style.left = x + 'px';
    pill.style.top  = y + 'px';
  }
  function hidePill(){ pill.style.display = 'none'; }

  // Hide when leaving the map or scrolling the page (prevents lingering/trailing)
  container.addEventListener('mouseleave', hidePill);
  container.addEventListener('pointerleave', hidePill);
  document.addEventListener('scroll', hidePill, true);
  window.addEventListener('blur', hidePill);

  // Hover + click handlers on merged hitboxes only
  map.eachLayer(function(layer) {
    if (layer instanceof L.GeoJSON) {
      layer.eachLayer(function(child) {
        var slug = child && child.feature && child.feature.properties && child.feature.properties.slug;
        if (!slug) return;

        child.on('mouseover',  function(e){ setCountryHover(slug, true);  showPill(slug, e); });
        child.on('mousemove',  function(e){ movePill(e); });
        child.on('mouseout',   function(e){ setCountryHover(slug, false); hidePill(); });

        child.on('touchstart', function(e){ setCountryHover(slug, true);  showPill(slug, e); });
        child.on('touchmove',  function(e){ movePill(e); });
        child.on('touchend',   function(e){ setCountryHover(slug, false); hidePill(); });
        child.on('touchcancel',function(e){ setCountryHover(slug, false); hidePill(); });

        child.on('click', function(){ var target = urlBySlug[slug]; if (target) window.open(target, '_blank'); });
      });
    }
  });
});
</script>
"""

m.get_root().html.add_child(folium.Element(js))

# ---------- Fit bounds to DOTS (tight framing, zero padding) ----------
dots_ll = gpd.GeoSeries(land_dots_scaled.geometry, crs="EPSG:3857").to_crs(epsg=4326)
minx, miny, maxx, maxy = dots_ll.total_bounds
pad_lon = 0.2
pad_lat = 0.2
m.fit_bounds([[miny + pad_lat, minx + pad_lon], [maxy - pad_lat, maxx - pad_lon]], padding=(0, 0))

# Save
output_filename = "falinwa_static_style_map.html"
m.save(output_filename)
print(f"Successfully created static-style interactive HTML map: '{output_filename}'")


```
